<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tạo Khung Ảnh Đại Diện</title>
    <!-- Import Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Import Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        /* Custom styles for file input */
        .file-input-button {
            cursor: pointer;
            border: 2px dashed #d1d5db;
            transition: all 0.2s ease-in-out;
        }
        .file-input-button:hover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        /* Custom styles for range slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]:focus {
            outline: none;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 3px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fb923c;
            cursor: pointer;
            margin-top: -7px; /* You need to specify a margin in Chrome, but not in Firefox */
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #d1d5db;
            border-radius: 3px;
        }
        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #fb923c;
            cursor: pointer;
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-6xl">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800">Tạo Khung Ảnh Đại Diện</h1>
            <p class="text-lg text-gray-500 mt-2">Tải ảnh, điều chỉnh và tạo dấu ấn cá nhân!</p>
        </header>

        <!-- Main Content: Changed to a 2-column layout -->
        <main class="grid grid-cols-1 md:grid-cols-2 gap-8 items-start">
            <!-- Left Panel: Controls -->
            <aside class="md:col-span-1 bg-white p-6 rounded-lg shadow-md h-fit">
                <!-- Step 1: Upload -->
                <div class="mb-6">
                    <h2 class="text-2xl font-semibold mb-2">Tải ảnh lên</h2>
                    <p class="text-gray-600 mb-4">Chọn một ảnh từ máy tính hoặc điện thoại.</p>
                    <label for="image-loader" class="file-input-button w-full block text-center p-6 rounded-lg bg-blue-50 hover:bg-blue-100 border-blue-300">
                        <span class="font-semibold text-blue-600">Chọn ảnh</span>
                    </label>
                    <input type="file" id="image-loader" class="hidden" accept="image/*">
                </div>

                <hr class="my-6 border-gray-200">

                <!-- Step 2: Download -->
                <div>
                    <h2 class="text-2xl font-semibold mb-2">Lưu lại thành quả</h2>
                    <p class="text-gray-600 mb-4">Tải ảnh đã ghép khung về máy của bạn.</p>
                    <button id="download-btn" class="w-full bg-orange-400 hover:bg-orange-500 text-white font-bold py-3 px-4 rounded-lg transition duration-300" disabled>
                        Tải ảnh về
                    </button>
                </div>
            </aside>

            <!-- Right Panel: Canvas Preview -->
            <div class="md:col-span-1">
                <div id="canvas-container" class="relative w-full aspect-square bg-white rounded-lg shadow-md flex items-center justify-center overflow-hidden">
                    <canvas id="avatar-canvas" width="1024" height="1024" class="w-full h-full"></canvas>
                    <div id="placeholder-text" class="absolute text-gray-500 text-center font-semibold">
                        <p>Chọn ảnh và bắt đầu</p>
                    </div>
                </div>
                <div class="bg-white p-4 mt-4 rounded-lg shadow-md">
                    <h3 class="font-semibold mb-2">Phóng to / Thu nhỏ</h3>
                    <p class="text-sm text-gray-600 mb-3">Dùng chuột để di chuyển ảnh, dùng thanh trượt để chỉnh kích thước.</p>
                    <input type="range" id="zoom-slider" min="0.1" max="3" step="0.01" value="1" class="w-full" disabled>
                </div>
            </div>
        </main>
    </div>

    <script>
        const canvas = document.getElementById('avatar-canvas');
        const ctx = canvas.getContext('2d');
        const imageLoader = document.getElementById('image-loader');
        const downloadBtn = document.getElementById('download-btn');
        const zoomSlider = document.getElementById('zoom-slider');
        const placeholderText = document.getElementById('placeholder-text');

        const FRAME_URL = 'https://res.cloudinary.com/dzfuqyqoq/image/upload/v1752215146/sdfgfdhgfh_ux81fr.png';
        const CANVAS_SIZE = 1024;
        const CIRCLE_RADIUS = 306; // 612 / 2

        let frame = new Image();
        frame.crossOrigin = "Anonymous"; // Important for downloading
        frame.src = FRAME_URL;

        let userImage = null;
        let scale = 1;
        let offset = { x: 0, y: 0 };
        let isDragging = false;
        let startDrag = { x: 0, y: 0 };

        // Draw the frame once it's loaded
        frame.onload = () => {
            redrawCanvas();
        };

        // Redraws the entire canvas based on current state
        function redrawCanvas() {
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Draw user image if it exists
            if (userImage) {
                placeholderText.style.display = 'none';
                ctx.save();
                
                // Create a circular clipping path
                ctx.beginPath();
                ctx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CIRCLE_RADIUS, 0, Math.PI * 2, true);
                ctx.clip();

                // Calculate scaled dimensions
                const scaledWidth = userImage.width * scale;
                const scaledHeight = userImage.height * scale;
                
                // Calculate position to draw the image
                const drawX = (CANVAS_SIZE - scaledWidth) / 2 + offset.x;
                const drawY = (CANVAS_SIZE - scaledHeight) / 2 + offset.y;

                // Draw the user's image
                ctx.drawImage(userImage, drawX, drawY, scaledWidth, scaledHeight);

                ctx.restore();
            } else {
                 placeholderText.style.display = 'flex';
            }

            // Draw the frame on top
            if (frame.complete) {
                ctx.drawImage(frame, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
        }

        // Handle image upload
        imageLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = () => {
                userImage = new Image();
                userImage.src = reader.result;
                userImage.onload = () => {
                    // Reset state for the new image
                    offset = { x: 0, y: 0 };
                    // Set initial scale to fit the circle
                    const hRatio = (CIRCLE_RADIUS * 2) / userImage.width;
                    const vRatio = (CIRCLE_RADIUS * 2) / userImage.height;
                    scale = Math.max(hRatio, vRatio); // Use max to fill the circle
                    zoomSlider.value = scale;
                    
                    // Enable controls
                    downloadBtn.disabled = false;
                    zoomSlider.disabled = false;
                    
                    redrawCanvas();
                };
            };
            reader.readAsDataURL(file);
        });

        // Handle zoom slider
        zoomSlider.addEventListener('input', (e) => {
            if (!userImage) return;
            scale = parseFloat(e.target.value);
            redrawCanvas();
        });

        // Handle mouse drag for panning
        canvas.addEventListener('mousedown', (e) => {
            if (!userImage) return;
            isDragging = true;
            // Adjust for the canvas's position on the page
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            startDrag.x = e.clientX - offset.x / scaleX;
            startDrag.y = e.clientY - offset.y / scaleY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging && userImage) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                offset.x = (e.clientX - startDrag.x) * scaleX;
                offset.y = (e.clientY - startDrag.y) * scaleY;
                redrawCanvas();
            }
        });

        const stopDragging = () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        };
        canvas.addEventListener('mouseup', stopDragging);
        canvas.addEventListener('mouseleave', stopDragging);
        
        // Handle download
        downloadBtn.addEventListener('click', () => {
            if (!userImage) return;
            // Redraw one last time to ensure quality
            redrawCanvas();

            const link = document.createElement('a');
            link.download = 'avatar-khung.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Initial draw
        redrawCanvas();
    </script>

</body>
</html>
